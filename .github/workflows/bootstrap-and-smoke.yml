name: "Bootstrap 2.0 • code + csv repair + seed + smoke + exports"

on:
  workflow_dispatch:
  push:
    branches: ["main"]

permissions:
  contents: write

concurrency:
  group: bootstrap2-${{ github.ref }}
  cancel-in-progress: true

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Ensure folders"
        run: mkdir -p utils pages data templates .streamlit tools

      - name: "Write core files"
        run: |
          cat > README.md <<'MD'
          # Cost Forge 2 — Full + Legacy
          - Quick Cost (beste quotes), Data Quality, Scenario Planner
          - Supplier Quotes, DOCX/PDF export, Download Center
          - Legacy-vriendelijke structuur (utils/pages/data)

          ## Lokaal starten
          ```bash
          pip install -r requirements.txt
          streamlit run home.py
          ```
          MD

          cat > requirements.txt <<'REQ'
          streamlit>=1.36
          pandas>=2.2
          python-docx>=1.1.0
          reportlab>=4.1
          ruff>=0.5
          REQ

          cat > .gitignore <<'GI'
          __pycache__/
          .venv/
          venv/
          *.py[cod]
          .DS_Store
          Thumbs.db
          .cache/
          *.zip
          artifacts/
          GI

          cat > pyproject.toml <<'TOML'
          [tool.ruff]
          line-length = 100
          target-version = "py311"

          [tool.ruff.lint]
          select = ["E","F","I"]
          ignore = ["E501"]

          [tool.ruff.format]
          docstring-code-format = true
          TOML

          cat > home.py <<'PY'
          import streamlit as st
          st.set_page_config(page_title="Cost Forge 2", layout="wide")
          st.title("🛠️ Cost Forge 2")
          st.write("Quick Cost, Data Quality, Scenario Planner, Supplier Quotes, DOCX/PDF Export, Download Center")
          PY

      - name: "Write utils (core)"
        run: |
          cat > utils/safe.py <<'PY'
          import streamlit as st
          def guard(fn):
              try:
                  fn()
              except Exception as e:
                  st.error(f"{type(e).__name__}: {e}")
                  st.stop()
          PY

          cat > utils/io.py <<'PY'
          from pathlib import Path
          import pandas as pd

          SCHEMA_MATERIALS = {"material_id":"string","description":"string","price_eur_per_kg":"float64"}
          SCHEMA_PROCESSES = {"process_id":"string","machine_rate_eur_h":"float64","labor_rate_eur_h":"float64","overhead_pct":"float64","margin_pct":"float64"}
          SCHEMA_BOM = {"line_id":"string","material_id":"string","qty":"Int64","mass_kg":"float64","process_route":"string","runtime_h":"float64"}
          SCHEMA_QUOTES = {"supplier":"string","material_id":"string","price_eur_per_kg":"float64","lead_time_days":"Int64","valid_until":"string","preferred":"Int64"}

          def paths():
              d = Path("data")
              return {
                  "materials": d/"materials_db.csv",
                  "processes": d/"processes_db.csv",
                  "bom": d/"bom_template.csv",
                  "quotes": d/"supplier_quotes.csv",
              }

          def _read_csv(p, schema=None):
              if schema is None:
                  return pd.read_csv(p)
              dtypes = {k:v for k,v in schema.items() if v!="Int64"}
              df = pd.read_csv(p, dtype=dtypes)
              for c,t in schema.items():
                  if t=="Int64" and c in df.columns:
                      df[c] = df[c].astype("Int64")
              return df

          def load_materials(): return _read_csv(paths()["materials"], SCHEMA_MATERIALS)
          def load_processes(): return _read_csv(paths()["processes"], SCHEMA_PROCESSES)
          def load_bom(): return _read_csv(paths()["bom"], SCHEMA_BOM)
          def load_quotes(): return _read_csv(paths()["quotes"], SCHEMA_QUOTES)
          PY

          cat > utils/pricing.py <<'PY'
          def compute_costs(mats, procs, bom):
              df = (
                  bom.merge(mats, on="material_id", how="left")
                     .merge(procs, left_on="process_route", right_on="process_id", how="left")
              )
              required = ["mass_kg","price_eur_per_kg","runtime_h","machine_rate_eur_h","labor_rate_eur_h","overhead_pct","margin_pct"]
              missing = [c for c in required if c not in df.columns]
              if missing:
                  raise ValueError(f"Ontbrekende kolommen: {missing}")
              df["material_cost"] = df["mass_kg"] * df["price_eur_per_kg"]
              df["process_cost"] = df["runtime_h"] * (df["machine_rate_eur_h"] + df["labor_rate_eur_h"])
              df["overhead"] = (df["material_cost"] + df["process_cost"]) * df["overhead_pct"]
              df["base_cost"] = df["material_cost"] + df["process_cost"] + df["overhead"]
              df["margin"] = df["base_cost"] * df["margin_pct"]
              df["total_cost"] = df["base_cost"] + df["margin"]
              return df
          PY

          cat > utils/quotes.py <<'PY'
          import pandas as pd

          def best_quotes(quotes: pd.DataFrame) -> pd.DataFrame:
              q = quotes.copy()
              q["preferred"] = q.get("preferred", 0)
              q["lead_time_days"] = q.get("lead_time_days", 999_999)
              q = q.sort_values(
                  by=["material_id","preferred","price_eur_per_kg","lead_time_days"],
                  ascending=[True,False,True,True]
              )
              return q.groupby("material_id").head(1).reset_index(drop=True)

          def apply_best_quotes(materials: pd.DataFrame, quotes: pd.DataFrame) -> pd.DataFrame:
              best = best_quotes(quotes)
              m = materials.merge(
                  best[["material_id","price_eur_per_kg","supplier","lead_time_days"]],
                  on="material_id", how="left", suffixes=("", "_quote")
              )
              if "price_eur_per_kg_quote" in m.columns:
                  if "price_eur_per_kg" not in m.columns:
                      m["price_eur_per_kg"] = m["price_eur_per_kg_quote"]
                  else:
                      m["price_eur_per_kg"] = m["price_eur_per_kg"].fillna(m["price_eur_per_kg_quote"])
                  m = m.drop(columns=["price_eur_per_kg_quote"])
              return m

          def join_with_materials(materials: pd.DataFrame, best: pd.DataFrame) -> pd.DataFrame:
              return materials.drop(columns=["price_eur_per_kg"], errors="ignore").merge(
                  best[["material_id","supplier","price_eur_per_kg","lead_time_days"]],
                  on="material_id", how="left"
              )
          PY

          cat > utils/docx_export.py <<'PY'
          from io import BytesIO
          from docx import Document
          from docx.enum.text import WD_ALIGN_PARAGRAPH

          def make_offer_docx(df, title: str = "Offerte") -> bytes:
              doc = Document()
              doc.add_heading(title, 0).alignment = WD_ALIGN_PARAGRAPH.LEFT
              total = float(df["total_cost"].sum())
              p = doc.add_paragraph("Totaalprijs: ")
              p.add_run(f"EUR {total:,.2f}").bold = True

              table = doc.add_table(rows=1, cols=7)
              hdr = ["Line","Material","Qty","Mat. cost","Proc. cost","Overhead","Total"]
              for i,t in enumerate(hdr): table.rows[0].cells[i].text = t

              for _, r in df.iterrows():
                  row = table.add_row().cells
                  row[0].text = str(r.get("line_id",""))
                  row[1].text = str(r.get("material_id",""))
                  row[2].text = str(r.get("qty",""))
                  row[3].text = f"{r.get('material_cost',0):,.2f}"
                  row[4].text = f"{r.get('process_cost',0):,.2f}"
                  row[5].text = f"{r.get('overhead',0):,.2f}"
                  row[6].text = f"{r.get('total_cost',0):,.2f}"

              bio = BytesIO()
              doc.save(bio)
              return bio.getvalue()
          PY

          cat > utils/pdf_export.py <<'PY'
          from io import BytesIO
          from reportlab.lib import colors
          from reportlab.lib.pagesizes import A4
          from reportlab.lib.styles import getSampleStyleSheet
          from reportlab.platypus import Paragraph, SimpleDocTemplate, Spacer, Table, TableStyle

          def make_offer_pdf(df, title: str = "Offerte") -> bytes:
              buf = BytesIO()
              doc = SimpleDocTemplate(buf, pagesize=A4)
              styles = getSampleStyleSheet()
              story = []

              story.append(Paragraph(f"<b>{title}</b>", styles["Title"]))
              story.append(Spacer(1, 12))

              total = float(df["total_cost"].sum())
              story.append(Paragraph(f"Totaalprijs: <b>EUR {total:,.2f}</b>", styles["Normal"]))

              headers = ["Line","Material","Qty","Mat. cost","Proc. cost","Overhead","Total"]
              rows = [[
                  str(r.get("line_id","")), str(r.get("material_id","")), str(r.get("qty","")),
                  f"{r.get('material_cost',0):,.2f}", f"{r.get('process_cost',0):,.2f}",
                  f"{r.get('overhead',0):,.2f}", f"{r.get('total_cost',0):,.2f}"
              ] for _, r in df.iterrows()]

              t = Table([headers] + rows)
              t.setStyle(TableStyle([
                  ("GRID",(0,0),(-1,-1),0.5,colors.grey),
                  ("BACKGROUND",(0,0),(-1,0),colors.lightgrey),
                  ("ALIGN",(2,1),(-1,-1),"RIGHT"),
              ]))
              story.append(t)
              doc.build(story)
              return buf.getvalue()
          PY

          cat > utils/validators.py <<'PY'
          from __future__ import annotations
          from dataclasses import dataclass
          from typing import Iterable, List, Mapping, Sequence
          import pandas as pd

          def check_missing(df: pd.DataFrame, required: Iterable[str]) -> List[str]:
              req = list(required)
              return [c for c in req if c not in df.columns]

          def check_positive(df: pd.DataFrame, cols: Iterable[str]) -> List[str]:
              bad=[]
              for c in cols:
                  if c not in df.columns:
                      continue
                  s = pd.to_numeric(df[c], errors="coerce")
                  if (s <= 0).any():
                      bad.append(c)
              return bad

          @dataclass(frozen=True)
          class Rule:
              name: str
              ok: bool
              msg: str

          def within(df: pd.DataFrame, col: str, lo: float | None, hi: float | None) -> bool:
              if col not in df.columns: return False
              s = pd.to_numeric(df[col], errors="coerce"); good = True
              if lo is not None: good &= (s >= lo).all()
              if hi is not None: good &= (s <= hi).all()
              return bool(good)

          def business_rules(mats: pd.DataFrame, procs: pd.DataFrame, bom: pd.DataFrame) -> List[Rule]:
              rules: List[Rule] = []
              rules.append(Rule("rates_positive", within(procs,"machine_rate_eur_h",0.01,None) and within(procs,"labor_rate_eur_h",0.01,None), "Machine- en arbeidsloon moeten > 0 zijn."))
              rules.append(Rule("overhead_pct_range", within(procs,"overhead_pct",0.0,1.0), "overhead_pct moet tussen 0 en 1 liggen."))
              rules.append(Rule("margin_pct_range", within(procs,"margin_pct",0.0,1.0), "margin_pct moet tussen 0 en 1 liggen."))
              rules.append(Rule("qty_min_1", within(bom,"qty",1,None), "qty moet >= 1 zijn."))
              rules.append(Rule("mass_positive", within(bom,"mass_kg",0.000001,None), "mass_kg moet > 0 zijn."))
              rules.append(Rule("runtime_nonneg", within(bom,"runtime_h",0.0,None), "runtime_h moet >= 0 zijn."))
              rules.append(Rule("mat_price_pos", within(mats,"price_eur_per_kg",0.000001,None), "Materiaalprijs moet > 0 zijn."))
              return rules

          def summarize_rules(rules: Sequence[Rule]) -> str:
              return "\n".join(("✅ " if r.ok else "❌ ") + f"{r.name}: " + ("OK" if r.ok else r.msg) for r in rules)

          def all_rules_ok(rules: Sequence[Rule]) -> bool:
              return all(r.ok for r in rules)
          PY

      - name: "Write pages"
        run: |
          cat > pages/01_Quick_Cost.py <<'PY'
          from utils.safe import guard
          from utils.io import load_bom, load_materials, load_processes, load_quotes
          from utils.pricing import compute_costs
          from utils.quotes import apply_best_quotes
          import streamlit as st
          def main():
              st.title("💸 Quick Cost (beste quotes)")
              mats = load_materials(); procs = load_processes(); bom = load_bom(); quotes = load_quotes()
              df = compute_costs(apply_best_quotes(mats, quotes), procs, bom)
              st.dataframe(df[["line_id","material_id","qty","material_cost","process_cost","overhead","margin","total_cost"]])
              st.metric("Totaal", f"EUR {df['total_cost'].sum():,.2f}")
          guard(main)
          PY

          cat > pages/05_Data_Quality.py <<'PY'
          from utils.safe import guard
          from utils.io import load_bom, load_materials, load_processes
          from utils.validators import check_missing, check_positive, business_rules, summarize_rules, all_rules_ok
          import streamlit as st
          def main():
              st.title("🧪 Data Quality + Guardrails")
              mats = load_materials(); procs = load_processes(); bom = load_bom()
              m1 = check_missing(mats, ["material_id","price_eur_per_kg"]); m2 = check_positive(mats, ["price_eur_per_kg"])
              p1 = check_missing(procs, ["process_id","machine_rate_eur_h","labor_rate_eur_h","overhead_pct","margin_pct"])
              p2 = check_positive(procs, ["machine_rate_eur_h","labor_rate_eur_h"])
              b1 = check_missing(bom, ["line_id","material_id","qty","mass_kg","process_route","runtime_h"])
              b2 = check_positive(bom, ["qty","mass_kg"])
              if any([m1,m2,p1,p2,b1,b2]):
                  if m1: st.error(f"materials miss: {m1}")
                  if m2: st.error(f"materials ≤0: {m2}")
                  if p1: st.error(f"processes miss: {p1}")
                  if p2: st.error(f"processes ≤0: {p2}")
                  if b1: st.error(f"bom miss: {b1}")
                  if b2: st.error(f"bom ≤0: {b2}")
              else:
                  st.success("Structuur OK")
              st.subheader("Business rules")
              rules = business_rules(mats, procs, bom)
              st.code(summarize_rules(rules))
              if all_rules_ok(rules): st.success("Alle business rules OK")
              else: st.error("Business rules schendingen: zie boven.")
          guard(main)
          PY

          cat > pages/06_Scenario_Planner.py <<'PY'
          from utils.safe import guard
          from utils.io import load_bom, load_materials, load_processes
          from utils.pricing import compute_costs
          import streamlit as st
          def main():
              st.title("🧭 Scenario Planner")
              mats = load_materials().copy(); procs = load_processes().copy(); bom = load_bom().copy()
              mat_delta = st.sidebar.slider("Materiaalprijs ± %", -50, 50, 0, 5)
              labor_delta = st.sidebar.slider("Arbeidsloon ± %", -50, 50, 0, 5)
              margin_delta = st.sidebar.slider("Marge ± %-punten", -20, 20, 0, 1)
              mats["price_eur_per_kg"] *= 1 + mat_delta/100.0
              procs["labor_rate_eur_h"] *= 1 + labor_delta/100.0
              procs["margin_pct"] += margin_delta/100.0
              df = compute_costs(mats, procs, bom)
              st.metric("Nieuw totaal (EUR)", f"{df['total_cost'].sum():,.2f}")
              st.dataframe(df[["line_id","material_id","material_cost","process_cost","overhead","margin","total_cost"]])
          guard(main)
          PY

          cat > pages/07_Supplier_Quotes.py <<'PY'
          from utils.safe import guard
          from utils.io import load_materials, load_quotes
          from utils.quotes import best_quotes, join_with_materials
          import streamlit as st
          def main():
              st.title("🤝 Supplier Quotes")
              quotes = load_quotes(); mats = load_materials(); best = best_quotes(quotes)
              st.subheader("Beste quotes per materiaal"); st.dataframe(best)
              st.subheader("Materialen verrijkt met beste leverancier"); st.dataframe(join_with_materials(mats, best))
          guard(main)
          PY

          cat > pages/18_Offerte_DOCX.py <<'PY'
          from utils.safe import guard
          from utils.docx_export import make_offer_docx
          from utils.io import load_bom, load_materials, load_processes, load_quotes
          from utils.pricing import compute_costs
          from utils.quotes import apply_best_quotes
          import streamlit as st
          def main():
              st.title("📄 Offerte DOCX")
              mats = load_materials(); procs = load_processes(); bom = load_bom(); quotes = load_quotes()
              df = compute_costs(apply_best_quotes(mats, quotes), procs, bom)
              st.metric("Totaal", f"EUR {df['total_cost'].sum():,.2f}")
              st.dataframe(df[["line_id","material_id","qty","material_cost","process_cost","overhead","total_cost"]])
              st.download_button("Download offerte.docx", make_offer_docx(df), "offerte.docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document")
          guard(main)
          PY

          cat > pages/19_Offerte_PDF.py <<'PY'
          from utils.safe import guard
          from utils.io import load_bom, load_materials, load_processes, load_quotes
          from utils.pdf_export import make_offer_pdf
          from utils.pricing import compute_costs
          from utils.quotes import apply_best_quotes
          import streamlit as st
          def main():
              st.title("🧾 Offerte PDF")
              mats = load_materials(); procs = load_processes(); bom = load_bom(); quotes = load_quotes()
              df = compute_costs(apply_best_quotes(mats, quotes), procs, bom)
              st.metric("Totaal", f"EUR {df['total_cost'].sum():,.2f}")
              st.dataframe(df[["line_id","material_id","qty","material_cost","process_cost","overhead","total_cost"]])
              st.download_button("Download offerte.pdf", make_offer_pdf(df), "offerte.pdf", "application/pdf")
          guard(main)
          PY

          cat > pages/20_Download_Center.py <<'PY'
          from utils.safe import guard
          from utils.io import paths
          import streamlit as st
          def main():
              st.title("📥 Download Center")
              p = paths()
              files=[("Materials template","materials"),("Processes template","processes"),("BOM template","bom"),("Supplier quotes","quotes")]
              for label,key in files:
                  f = p[key]
                  try:
                      st.download_button(f"Download {label}", data=f.read_bytes(), file_name=f.name, mime="text/csv")
                  except FileNotFoundError:
                      st.warning(f"Bestand ontbreekt: {f}")
          guard(main)
          PY

      - name: "Install dependencies"
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: "CSVs • create/repair + ALWAYS seed demo if empty"
        run: |
          python - <<'PY'
          import pandas as pd
          from utils.io import SCHEMA_MATERIALS, SCHEMA_PROCESSES, SCHEMA_BOM, SCHEMA_QUOTES, paths
          P = paths()

          def ensure_schema_and_seed(path, schema, seed_rows):
              cols = list(schema.keys())
              try:
                  df = pd.read_csv(path)
              except FileNotFoundError:
                  df = pd.DataFrame(columns=cols)
              # Zorg dat alle schema-kolommen bestaan
              for c in cols:
                  if c not in df.columns:
                      df[c] = pd.NA
              # SEED als leeg
              if df.empty and seed_rows:
                  df = pd.DataFrame(seed_rows, columns=cols)
              df = df[list(dict.fromkeys(list(df.columns) + cols))]
              df.to_csv(path, index=False)

          ensure_schema_and_seed(P["materials"], SCHEMA_MATERIALS, [
              {"material_id":"AL6061","description":"Aluminium 6061","price_eur_per_kg":4.5},
              {"material_id":"S235","description":"Staal S235","price_eur_per_kg":1.1}
          ])
          ensure_schema_and_seed(P["processes"], SCHEMA_PROCESSES, [
              {"process_id":"MILLING_CNC_3AX","machine_rate_eur_h":80,"labor_rate_eur_h":45,"overhead_pct":0.2,"margin_pct":0.1},
              {"process_id":"TURNING_CNC","machine_rate_eur_h":70,"labor_rate_eur_h":45,"overhead_pct":0.2,"margin_pct":0.1}
          ])
          ensure_schema_and_seed(P["bom"], SCHEMA_BOM, [
              {"line_id":"L1","material_id":"AL6061","qty":10,"mass_kg":2.4,"process_route":"MILLING_CNC_3AX","runtime_h":0.4},
              {"line_id":"L2","material_id":"S235","qty":6,"mass_kg":5.0,"process_route":"TURNING_CNC","runtime_h":0.35}
          ])
          ensure_schema_and_seed(P["quotes"], SCHEMA_QUOTES, [
              {"supplier":"Metals4U","material_id":"AL6061","price_eur_per_kg":4.4,"lead_time_days":7,"valid_until":"2025-12-31","preferred":1},
              {"supplier":"SteelCo","material_id":"S235","price_eur_per_kg":1.05,"lead_time_days":10,"valid_until":"2025-11-15","preferred":1}
          ])
          print("✅ CSV's gerepareerd/gezaaid (altijd gevuld als leeg).")
          PY

      - name: "Ruff • format + lint (Python only)"
        run: |
          python -m pip install --upgrade pip
          pip install ruff
          ruff format utils pages home.py
          ruff check --fix utils pages home.py
          ruff check utils pages home.py --output-format=github || true

      - name: "Commit & push (fallback if main protected)"
        shell: bash
        run: |
          set -e
          git add -A
          if git diff --cached --quiet; then
            echo "ℹ️ Geen wijzigingen."
            exit 0
          fi
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git commit -m "Bootstrap 2.0: code + csv repair/seed + smoke set-up"
          if git push origin HEAD:main; then
            echo "✅ Gecommit naar main."
          else
            TS=$(date +%Y%m%d-%H%M%S)
            BR="bootstrap2/${TS}"
            git switch -c "$BR"
            git push -u origin "$BR"
            echo "::notice title=Open Pull Request::https://github.com/${GITHUB_REPOSITORY}/compare/${BR}?expand=1"
          fi

  smoke:
    needs: bootstrap
    if: ${{ always() }}
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: "Checkout (latest)"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Setup Python"
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: "Install deps"
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: "CSV schema check (fail on missing only)"
        run: |
          python - <<'PY'
          import sys, pandas as pd
          from utils.io import SCHEMA_MATERIALS,SCHEMA_PROCESSES,SCHEMA_BOM,SCHEMA_QUOTES,paths
          SCHEMAS = {
              "materials_db.csv": (paths()["materials"], SCHEMA_MATERIALS),
              "processes_db.csv": (paths()["processes"], SCHEMA_PROCESSES),
              "bom_template.csv": (paths()["bom"], SCHEMA_BOM),
              "supplier_quotes.csv": (paths()["quotes"], SCHEMA_QUOTES),
          }
          ok = True
          for name, (p, schema) in SCHEMAS.items():
              df = pd.read_csv(p)
              missing = [c for c in schema if c not in df.columns]
              if missing:
                  print(f"[SCHEMA] {name} ontbreekt: {missing}")
                  ok = False
              if df.empty:
                  print(f"[SCHEMA] {name} is leeg (seed had moeten vullen).")
                  ok = False
          if not ok:
              sys.exit(1)
          print("Schema OK")
          PY

      - name: "E2E compute + exports"
        run: |
          mkdir -p artifacts
          python - <<'PY'
          from utils.io import load_materials,load_processes,load_bom,load_quotes
          from utils.quotes import apply_best_quotes
          from utils.pricing import compute_costs
          from utils.docx_export import make_offer_docx
          from utils.pdf_export import make_offer_pdf

          mats=load_materials(); procs=load_processes(); bom=load_bom(); quotes=load_quotes()
          df = compute_costs(apply_best_quotes(mats, quotes), procs, bom)
          assert "total_cost" in df.columns, "total_cost ontbreekt in DF"
          assert len(df) >= 1, "Geen rijen in DF (CSV's leeg?)"
          open("artifacts/offerte.docx","wb").write(make_offer_docx(df))
          open("artifacts/offerte.pdf","wb").write(make_offer_pdf(df))
          print("TOTAL:", float(df["total_cost"].sum()))
          PY

      - name: "Upload artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: offer-exports
          path: artifacts/
